<haxe>
	<class path="neko.Lib" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/neko/Lib.hx">
		<load public="1" line="32" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<d/>
			</f>
			<haxe_doc>
		Load and return a Neko primitive from a NDLL library.
	</haxe_doc>
		</load>
		<loadLazy public="1" line="36" static="1"><f a="lib:prim:nargs">
	<c path="String"/>
	<c path="String"/>
	<c path="Int"/>
	<d/>
</f></loadLazy>
		<print public="1" line="47" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Print the specified value on the default output.
	</haxe_doc>
		</print>
		<println public="1" line="54" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Print the specified value on the default output followed by a newline character.
	</haxe_doc>
		</println>
		<rethrow public="1" line="62" static="1">
			<f a="e">
				<d/>
				<d/>
			</f>
			<haxe_doc>
		Rethrow an exception. This is useful when manually filtering an exception in order
		to keep the previous exception stack.
	</haxe_doc>
		</rethrow>
		<serialize public="1" line="70" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Serialize using native Neko serialization. This will return a Binary string that can be
		stored for long term usage. The serialized data is optimized for speed and not for size.
	</haxe_doc>
		</serialize>
		<unserialize public="1" line="77" static="1">
			<f a="s">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Unserialize a string using native Neko serialization. See [serialize].
	</haxe_doc>
		</unserialize>
		<localUnserialize public="1" line="88" static="1">
			<f a="s">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Unserialize a string using native Neko serialization. See [serialize].
		This function assume that all the serialized data was serialized with current
		module, even if the module name was different. This can happen if you are unserializing
		some data into mod_neko that was serialized on a different server using a different
		file path.
	</haxe_doc>
		</localUnserialize>
		<nekoToHaxe public="1" line="98" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<haxe_doc>
		Converts a Neko value to its haXe equivalent. Used for wrapping String and Arrays raw values into haXe Objects.
	</haxe_doc>
		</nekoToHaxe>
		<haxeToNeko public="1" line="130" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<haxe_doc>
		Converts a Neko value to its haXe equivalent. Used to unwrap String and Arrays Objects into raw Neko values.
	</haxe_doc>
		</haxeToNeko>
		<getClasses public="1" line="165" static="1">
			<f a=""><d/></f>
			<haxe_doc>
		Returns an object containing all compiled packages and classes.
	</haxe_doc>
		</getClasses>
		<stringReference public="1" line="172" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a string referencing the data contains in bytes.
	</haxe_doc>
		</stringReference>
		<bytesReference public="1" line="179" static="1">
			<f a="s">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>
		Returns bytes referencing the content of a string.
	</haxe_doc>
		</bytesReference>
		<__serialize line="183" static="1"><f a="">
	<d/>
	<c path="String"/>
</f></__serialize>
		<__unserialize line="184" static="1"><f a=":">
	<unknown/>
	<a>
		<loadprim><f a="p:n">
	<unknown/>
	<unknown/>
	<unknown/>
</f></loadprim>
		<loadmodule><f a="m:l">
	<unknown/>
	<unknown/>
	<unknown/>
</f></loadmodule>
	</a>
	<unknown/>
</f></__unserialize>
	</class>
	<class path="neko.NekoDate__" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/neko/NekoDate__.hx">
		<__name__ line="29" static="1"><c path="Array"><c path="String"/></c></__name__>
		<now line="73" static="1"><f a=""><c path="neko.NekoDate__"/></f></now>
		<fromTime line="77" static="1"><f a="t">
	<c path="Float"/>
	<c path="neko.NekoDate__"/>
</f></fromTime>
		<fromString line="85" static="1"><f a="s">
	<c path="String"/>
	<c path="neko.NekoDate__"/>
</f></fromString>
		<new1 line="89" static="1"><f a="t">
	<e path="Void"/>
	<c path="neko.NekoDate__"/>
</f></new1>
		<date_new line="95" static="1"><f a="">
	<unknown/>
	<e path="Void"/>
</f></date_new>
		<date_now line="96" static="1"><f a=""><e path="Void"/></f></date_now>
		<date_format line="97" static="1"><f a=":">
	<e path="Void"/>
	<unknown/>
	<c path="String"/>
</f></date_format>
		<date_set_hour line="98" static="1"><f a=":::">
	<e path="Void"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></date_set_hour>
		<date_set_day line="99" static="1"><f a=":::">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></date_set_day>
		<date_get_day line="100" static="1"><f a="">
	<d/>
	<a>
		<y><c path="Int"/></y>
		<m><c path="Int"/></m>
		<d><c path="Int"/></d>
	</a>
</f></date_get_day>
		<date_get_hour line="101" static="1"><f a="">
	<d/>
	<a>
		<s><c path="Int"/></s>
		<m><c path="Int"/></m>
		<h><c path="Int"/></h>
	</a>
</f></date_get_hour>
		<int32_to_float line="102" static="1"><f a="">
	<e path="Void"/>
	<c path="Int"/>
</f></int32_to_float>
		<int32_add line="103" static="1"><f a=":">
	<unknown/>
	<unknown/>
	<e path="Void"/>
</f></int32_add>
		<int32_shl line="104" static="1"><f a=":">
	<unknown/>
	<c path="Int"/>
	<unknown/>
</f></int32_shl>
		<__t><e path="Void"/></__t>
		<getTime public="1" line="37"><f a=""><c path="Float"/></f></getTime>
		<getFullYear public="1" line="41"><f a=""><c path="Int"/></f></getFullYear>
		<getMonth public="1" line="45"><f a=""><c path="Int"/></f></getMonth>
		<getDate public="1" line="49"><f a=""><c path="Int"/></f></getDate>
		<getHours public="1" line="53"><f a=""><c path="Int"/></f></getHours>
		<getMinutes public="1" line="57"><f a=""><c path="Int"/></f></getMinutes>
		<getSeconds public="1" line="61"><f a=""><c path="Int"/></f></getSeconds>
		<getDay public="1" line="65"><f a=""><c path="Int"/></f></getDay>
		<toString public="1" line="69"><f a=""><c path="String"/></f></toString>
		<new public="1" line="32"><f a="year:month:day:hour:min:sec">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Enum" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/Enum.hx" extern="1"><haxe_doc>
	An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="utest.ui.common.PackageResult" params="" file="src/utest/ui/common/PackageResult.hx">
		<packageName public="1" set="null"><c path="String"/></packageName>
		<classes><c path="Hash"><c path="utest.ui.common.ClassResult"/></c></classes>
		<packages><c path="Hash"><c path="utest.ui.common.PackageResult"/></c></packages>
		<stats public="1" set="null"><c path="utest.ui.common.ResultStats"/></stats>
		<addResult public="1" line="23"><f a="result:flattenPackage">
	<c path="utest.TestResult"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addResult>
		<createFixture line="30"><f a="method:assertations">
	<c path="String"/>
	<t path="Iterable"><e path="utest.Assertation"/></t>
	<c path="utest.ui.common.FixtureResult"/>
</f></createFixture>
		<getOrCreateClass line="37"><f a="pack:cls:setup:teardown">
	<c path="utest.ui.common.PackageResult"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<t path="Null"><c path="utest.ui.common.ClassResult"/></t>
</f></getOrCreateClass>
		<getOrCreatePackage line="44"><f a="pack:flat:ref">
	<c path="String"/>
	<e path="Bool"/>
	<c path="utest.ui.common.PackageResult"/>
	<c path="utest.ui.common.PackageResult"/>
</f></getOrCreatePackage>
		<addClass public="1" line="61"><f a="result">
	<c path="utest.ui.common.ClassResult"/>
	<e path="Void"/>
</f></addClass>
		<addPackage public="1" line="66"><f a="result">
	<c path="utest.ui.common.PackageResult"/>
	<e path="Void"/>
</f></addPackage>
		<existsPackage public="1" line="71"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></existsPackage>
		<existsClass public="1" line="75"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></existsClass>
		<getPackage public="1" line="79"><f a="name">
	<c path="String"/>
	<t path="Null"><c path="utest.ui.common.PackageResult"/></t>
</f></getPackage>
		<getClass public="1" line="83"><f a="name">
	<c path="String"/>
	<t path="Null"><c path="utest.ui.common.ClassResult"/></t>
</f></getClass>
		<classNames public="1" line="87"><f a="?errorsHavePriority">
	<e path="Bool"/>
	<c path="Array"><c path="String"/></c>
</f></classNames>
		<packageNames public="1" line="120"><f a="?errorsHavePriority">
	<e path="Bool"/>
	<c path="Array"><c path="String"/></c>
</f></packageNames>
		<new public="1" line="16"><f a="packageName">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Test" params="" file="src/Test.hx"><main public="1" line="6" static="1"><f a=""><e path="Void"/></f></main></class>
	<class path="haxe.io.BytesBuffer" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/haxe/io/BytesBuffer.hx">
		<b><e path="Void"/></b>
		<addByte public="1" line="51"><f a="byte">
	<c path="Int"/>
	<e path="Void"/>
</f></addByte>
		<add public="1" line="63"><f a="src">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></add>
		<addBytes public="1" line="79"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></addBytes>
		<getBytes public="1" line="108">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>
		Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.
	</haxe_doc>
		</getBytes>
		<new public="1" line="39"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="XmlType" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/Xml.hx" module="Xml"><haxe_doc>
	An abstract type representing the type of the Xml
	Node. You can compare it to [Xml] statics and can
	use [Std.string(t)] to get a string reprensation
	of the type.
</haxe_doc></enum>
	<class path="neko.NekoXml__" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/neko/NekoXml__.hx">
		<__name__ line="30" static="1"><c path="Array"><c path="String"/></c></__name__>
		<_parse line="46" static="1"><f a=":">
	<unknown/>
	<a>
		<xml><f a="name:att">
	<c path="String"/>
	<unknown/>
	<e path="Void"/>
</f></xml>
		<pcdata><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></pcdata>
		<done><f a=""><e path="Void"/></f></done>
		<doctype><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></doctype>
		<cur><c path="neko.NekoXml__"/></cur>
		<comment><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></comment>
		<cdata><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></cdata>
	</a>
	<unknown/>
</f></_parse>
		<parse line="48" static="1"><f a="xmlData">
	<c path="String"/>
	<c path="neko.NekoXml__"/>
</f></parse>
		<createElement line="116" static="1"><f a="name">
	<c path="String"/>
	<c path="neko.NekoXml__"/>
</f></createElement>
		<createPCData line="125" static="1"><f a="data">
	<c path="String"/>
	<c path="neko.NekoXml__"/>
</f></createPCData>
		<createCData line="132" static="1"><f a="data">
	<c path="String"/>
	<c path="neko.NekoXml__"/>
</f></createCData>
		<createComment line="139" static="1"><f a="data">
	<c path="String"/>
	<c path="neko.NekoXml__"/>
</f></createComment>
		<createDocType line="146" static="1"><f a="data">
	<c path="String"/>
	<c path="neko.NekoXml__"/>
</f></createDocType>
		<createProlog line="153" static="1"><f a="data">
	<c path="String"/>
	<c path="neko.NekoXml__"/>
</f></createProlog>
		<createDocument line="160" static="1"><f a=""><c path="neko.NekoXml__"/></f></createDocument>
		<nodeName public="1" get="getNodeName" set="setNodeName"><c path="String"/></nodeName>
		<nodeValue public="1" get="getNodeValue" set="setNodeValue"><c path="String"/></nodeValue>
		<parent public="1" get="getParent" set="null"><c path="neko.NekoXml__"/></parent>
		<nodeType public="1" set="null"><e path="XmlType"/></nodeType>
		<_nodeName><c path="String"/></_nodeName>
		<_nodeValue><c path="String"/></_nodeValue>
		<_attributes><d><c path="String"/></d></_attributes>
		<_children><c path="Array"><c path="neko.NekoXml__"/></c></_children>
		<_parent><c path="neko.NekoXml__"/></_parent>
		<getNodeName line="167"><f a=""><c path="String"/></f></getNodeName>
		<setNodeName line="173"><f a="n">
	<c path="String"/>
	<c path="String"/>
</f></setNodeName>
		<getNodeValue line="179"><f a=""><c path="String"/></f></getNodeValue>
		<setNodeValue line="185"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></setNodeValue>
		<getParent line="191"><f a=""><c path="neko.NekoXml__"/></f></getParent>
		<get public="1" line="195"><f a="att">
	<c path="String"/>
	<c path="String"/>
</f></get>
		<set public="1" line="201"><f a="att:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></set>
		<remove public="1" line="207"><f a="att">
	<c path="String"/>
	<e path="Void"/>
</f></remove>
		<exists public="1" line="213"><f a="att">
	<c path="String"/>
	<e path="Bool"/>
</f></exists>
		<attributes public="1" line="219"><f a=""><t path="Iterator"><c path="String"/></t></f></attributes>
		<iterator public="1" line="225"><f a=""><t path="Iterator"><c path="neko.NekoXml__"/></t></f></iterator>
		<elements public="1" line="241"><f a=""><unknown/></f></elements>
		<elementsNamed public="1" line="274"><f a="name">
	<c path="String"/>
	<unknown/>
</f></elementsNamed>
		<firstChild public="1" line="308"><f a=""><c path="neko.NekoXml__"/></f></firstChild>
		<firstElement public="1" line="314"><f a=""><c path="neko.NekoXml__"/></f></firstElement>
		<addChild public="1" line="325"><f a="x">
	<c path="neko.NekoXml__"/>
	<e path="Void"/>
</f></addChild>
		<removeChild public="1" line="333"><f a="x">
	<c path="neko.NekoXml__"/>
	<e path="Bool"/>
</f></removeChild>
		<insertChild public="1" line="341"><f a="x:pos">
	<c path="neko.NekoXml__"/>
	<c path="Int"/>
	<e path="Void"/>
</f></insertChild>
		<toString public="1" line="349"><f a=""><c path="String"/></f></toString>
		<new line="43"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="neko.Boot" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/neko/Boot.hx">
		<__tmp_str line="29" static="1"><f a=""><c path="String"/></f></__tmp_str>
		<__enum_str line="33" static="1"><f a="e">
	<d/>
	<c path="String"/>
</f></__enum_str>
		<__interfLoop line="55" static="1"><f a="cc:cl">
	<d/>
	<d/>
	<e path="Bool"/>
</f></__interfLoop>
		<__instanceof line="70" static="1"><f a="o:cl">
	<a>
		<__name__><unknown/></__name__>
		<__enum__><t path="#Dynamic"/></__enum__>
		<__ename__><unknown/></__ename__>
		<__class__><unknown/></__class__>
	</a>
	<t path="#Dynamic"/>
	<e path="Bool"/>
</f></__instanceof>
		<__serialize line="88" static="1"><f a="o">
	<a>
		<__enum__><a><__ename__><a><length><c path="Int"/></length></a></__ename__></a></__enum__>
		<__class__><a><__name__><a><length><c path="Int"/></length></a></__name__></a></__class__>
	</a>
	<c path="Array"><unknown/></c>
</f></__serialize>
		<__tagserialize line="108" static="1"><f a="o">
	<a>
		<tag><unknown/></tag>
		<__enum__><a><__ename__><a><length><c path="Int"/></length></a></__ename__></a></__enum__>
	</a>
	<c path="Array"><unknown/></c>
</f></__tagserialize>
		<__unserialize line="117" static="1"><f a="v">
	<c path="Array"><unknown/></c>
	<unknown/>
</f></__unserialize>
		<__init line="140" static="1"><f a=""><e path="Void"/></f></__init>
	</class>
	<class path="Xml" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/Xml.hx" extern="1">
		<Element public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Element>
		<PCData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</PCData>
		<CData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</CData>
		<Comment public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Comment>
		<DocType public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</DocType>
		<Prolog public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Prolog>
		<Document public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Document>
		<parse public="1" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Parse a String into an Xml object.
	</haxe_doc>
		</parse>
		<createElement public="1" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createElement>
		<createPCData public="1" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createPCData>
		<createCData public="1" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createCData>
		<createComment public="1" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createComment>
		<createDocType public="1" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createDocType>
		<createProlog public="1" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createProlog>
		<createDocument public="1" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createDocument>
		<nodeType public="1" set="null">
			<e path="XmlType"/>
			<haxe_doc>
		Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.
	</haxe_doc>
		</nodeType>
		<nodeName public="1" get="getNodeName" set="setNodeName">
			<c path="String"/>
			<haxe_doc>
		Returns the node name of an Element.
	</haxe_doc>
		</nodeName>
		<getNodeName><f a=""><c path="String"/></f></getNodeName>
		<setNodeName><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></setNodeName>
		<nodeValue public="1" get="getNodeValue" set="setNodeValue">
			<c path="String"/>
			<haxe_doc>
		Returns the node value. Only works if the Xml node is not an Element or a Document.
	</haxe_doc>
		</nodeValue>
		<getNodeValue><f a=""><c path="String"/></f></getNodeValue>
		<setNodeValue><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></setNodeValue>
		<get public="1">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Get the given attribute of an Element node. Returns [null] if not found.
		Attributes are case-sensitive.
	</haxe_doc>
		</get>
		<set public="1">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set the given attribute value for an Element node.
		Attributes are case-sensitive.
	</haxe_doc>
		</set>
		<remove public="1">
			<f a="att">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Removes an attribute for an Element node.
		Attributes are case-sensitive.
	</haxe_doc>
		</remove>
		<exists public="1">
			<f a="att">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the Element node has a given attribute.
		Attributes are case-sensitive.
	</haxe_doc>
		</exists>
		<attributes public="1">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an [Iterator] on all the attributes values.
	</haxe_doc>
		</attributes>
		<parent public="1" get="getParent" set="null">
			<c path="Xml"/>
			<haxe_doc>
		Returns the parent object in the Xml hierarchy.
		The parent can be [null], an Element or a Document.
	</haxe_doc>
		</parent>
		<getParent><f a=""><c path="Xml"/></f></getParent>
		<iterator public="1">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>
		Returns an iterator of all child nodes.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</iterator>
		<elements public="1">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>
		Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</elements>
		<elementsNamed public="1">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>
		Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</elementsNamed>
		<firstChild public="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Returns the first child node.
	</haxe_doc>
		</firstChild>
		<firstElement public="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Returns the first child node which is an Element.
	</haxe_doc>
		</firstElement>
		<addChild public="1">
			<f a="x">
				<c path="Xml"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a child node to the Document or Element.
		One node can only be inside one given node which is indicated by the [parent] property.
	</haxe_doc>
		</addChild>
		<removeChild public="1">
			<f a="x">
				<c path="Xml"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.
	</haxe_doc>
		</removeChild>
		<insertChild public="1">
			<f a="x:pos">
				<c path="Xml"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts a child at the given position among the other childs.
	</haxe_doc>
		</insertChild>
		<toString public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a String representation of the Xml node.
	</haxe_doc>
		</toString>
		<haxe_doc>
	The standard Xml class and parsing.
	More API to manipulate XML are available in the [haxe.xml] package.
</haxe_doc>
	</class>
	<class path="neko.Sys" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/neko/Sys.hx">
		<args public="1" line="29" static="1"><f a=""><c path="Array"><c path="String"/></c></f></args>
		<getEnv public="1" line="44" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></getEnv>
		<putEnv public="1" line="51" static="1"><f a="s:v">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></putEnv>
		<sleep public="1" line="55" static="1"><f a="seconds">
	<c path="Float"/>
	<e path="Void"/>
</f></sleep>
		<setTimeLocale public="1" line="59" static="1"><f a="loc">
	<c path="String"/>
	<e path="Bool"/>
</f></setTimeLocale>
		<getCwd public="1" line="63" static="1"><f a=""><c path="String"/></f></getCwd>
		<setCwd public="1" line="67" static="1"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></setCwd>
		<systemName public="1" line="71" static="1"><f a=""><c path="String"/></f></systemName>
		<escapeArgument public="1" line="75" static="1"><f a="arg">
	<c path="String"/>
	<c path="String"/>
</f></escapeArgument>
		<command public="1" line="89" static="1"><f a="cmd:?args">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<c path="Int"/>
</f></command>
		<exit public="1" line="98" static="1"><f a="code">
	<c path="Int"/>
	<e path="Void"/>
</f></exit>
		<time public="1" line="102" static="1"><f a=""><c path="Float"/></f></time>
		<cpuTime public="1" line="106" static="1"><f a=""><c path="Float"/></f></cpuTime>
		<executablePath public="1" line="110" static="1"><f a=""><c path="String"/></f></executablePath>
		<environment public="1" line="114" static="1"><f a=""><c path="Hash"><c path="String"/></c></f></environment>
		<get_env line="124" static="1"><f a="">
	<unknown/>
	<c path="String"/>
</f></get_env>
		<put_env line="125" static="1"><f a=":">
	<unknown/>
	<unknown/>
	<unknown/>
</f></put_env>
		<_sleep line="126" static="1"><f a="">
	<c path="Float"/>
	<unknown/>
</f></_sleep>
		<set_time_locale line="127" static="1"><f a="">
	<unknown/>
	<e path="Bool"/>
</f></set_time_locale>
		<get_cwd line="128" static="1"><f a=""><c path="String"/></f></get_cwd>
		<set_cwd line="129" static="1"><f a="">
	<unknown/>
	<unknown/>
</f></set_cwd>
		<sys_string line="130" static="1"><f a=""><c path="String"/></f></sys_string>
		<sys_command line="131" static="1"><f a="">
	<unknown/>
	<c path="Int"/>
</f></sys_command>
		<sys_exit line="132" static="1"><f a="">
	<c path="Int"/>
	<unknown/>
</f></sys_exit>
		<sys_time line="133" static="1"><f a=""><c path="Float"/></f></sys_time>
		<sys_cpu_time line="134" static="1"><f a=""><c path="Float"/></f></sys_cpu_time>
		<sys_exe_path line="135" static="1"><f a=""><c path="String"/></f></sys_exe_path>
		<sys_env line="136" static="1"><f a=""><c path="Array"><d/></c></f></sys_env>
	</class>
	<class path="StringTools" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/StringTools.hx">
		<urlEncode public="1" line="38" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode an URL by using the standard format.
	</haxe_doc>
		</urlEncode>
		<urlDecode public="1" line="57" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Decode an URL using the standard format.
	</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" line="76" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Escape HTML special characters of the string.
	</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" line="83" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Unescape HTML special characters of the string.
	</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" line="94" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] starts with the string [start].
	</haxe_doc>
		</startsWith>
		<endsWith public="1" line="101" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] ends with the string [end].
	</haxe_doc>
		</endsWith>
		<isSpace public="1" line="110" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the character in the string [s] at position [pos] is a space.
	</haxe_doc>
		</isSpace>
		<ltrim public="1" line="118" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the left of the String [s].
	</haxe_doc>
		</ltrim>
		<rtrim public="1" line="137" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the right of the String [s].
	</haxe_doc>
		</rtrim>
		<trim public="1" line="157" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the beginning and the end of the String [s].
	</haxe_doc>
		</trim>
		<rpad public="1" line="168" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its right until it reach [l] characters.
	</haxe_doc>
		</rpad>
		<lpad public="1" line="190" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its left until it reach [l] characters.
	</haxe_doc>
		</lpad>
		<replace public="1" line="215" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replace all occurences of the string [sub] in the string [s] by the string [by].
	</haxe_doc>
		</replace>
		<hex public="1" line="226" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.
	</haxe_doc>
		</hex>
		<_urlEncode line="252" static="1"><f a="">
	<unknown/>
	<c path="String"/>
</f></_urlEncode>
		<_urlDecode line="253" static="1"><f a="">
	<unknown/>
	<c path="String"/>
</f></_urlDecode>
		<haxe_doc>
	The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.
</haxe_doc>
	</class>
	<class path="Array" params="T" file="C:\Programmi\Motion-Twin\haxe\haxe/std/Array.hx" extern="1">
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The length of the Array
	</haxe_doc>
		</length>
		<concat public="1">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Returns a new Array by appending [a] to [this].
	</haxe_doc>
		</concat>
		<join public="1">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of an array with [sep] for separating each element.
	</haxe_doc>
		</join>
		<pop public="1">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the last element of the array and returns it.
	</haxe_doc>
		</pop>
		<push public="1">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the end of the array.
	</haxe_doc>
		</push>
		<reverse public="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Reverse the order of elements of the Array.
	</haxe_doc>
		</reverse>
		<shift public="1">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the first element and returns it.
	</haxe_doc>
		</shift>
		<slice public="1">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.
	</haxe_doc>
		</slice>
		<sort public="1">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].
	]]></haxe_doc>
		</sort>
		<splice public="1">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Removes [len] elements starting from [pos] an returns them.
	</haxe_doc>
		</splice>
		<toString public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the Array content.
	</haxe_doc>
		</toString>
		<unshift public="1">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the start of the array.
	</haxe_doc>
		</unshift>
		<insert public="1">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.
	</haxe_doc>
		</insert>
		<remove public="1">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.
	</haxe_doc>
		</remove>
		<copy public="1">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>
		Returns a copy of the Array. The values are not
		copied, only the Array structure.
	</haxe_doc>
		</copy>
		<iterator public="1">
			<f a=""><t path="Iterator"><t path="Null"><c path="Array.T"/></t></t></f>
			<haxe_doc>
		Returns an iterator of the Array values.
	</haxe_doc>
		</iterator>
		<new public="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new Array.
	</haxe_doc>
		</new>
		<haxe_doc>
	An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.
</haxe_doc>
	</class>
	<class path="neko.NekoArray__" params="T" file="C:\Programmi\Motion-Twin\haxe\haxe/std/neko/NekoArray__.hx">
		<implements path="Array"><c path="neko.NekoArray__.T"/></implements>
		<__name__ line="29" static="1"><c path="Array"><c path="String"/></c></__name__>
		<new1 line="39" static="1"><f a="a:l">
	<unknown/>
	<c path="Int"/>
	<c path="neko.NekoArray__"><d/></c>
</f></new1>
		<length public="1" set="null"><c path="Int"/></length>
		<concat public="1" line="50"><f a="arr">
	<c path="Array"><c path="neko.NekoArray__.T"/></c>
	<c path="Array"><c path="neko.NekoArray__.T"/></c>
</f></concat>
		<copy public="1" line="63"><f a=""><c path="Array"><c path="neko.NekoArray__.T"/></c></f></copy>
		<iterator public="1" line="67"><f a=""><t path="Iterator"><t path="Null"><c path="neko.NekoArray__.T"/></t></t></f></iterator>
		<insert public="1" line="82"><f a="pos:x">
	<c path="Int"/>
	<c path="neko.NekoArray__.T"/>
	<e path="Void"/>
</f></insert>
		<join public="1" line="97"><f a="delim">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<toString public="1" line="109"><f a=""><c path="String"/></f></toString>
		<pop public="1" line="122"><f a=""><t path="Null"><c path="neko.NekoArray__.T"/></t></f></pop>
		<push public="1" line="133"><f a="v">
	<c path="neko.NekoArray__.T"/>
	<c path="Int"/>
</f></push>
		<unshift public="1" line="142"><f a="v">
	<c path="neko.NekoArray__.T"/>
	<e path="Void"/>
</f></unshift>
		<remove public="1" line="152"><f a="v">
	<c path="neko.NekoArray__.T"/>
	<e path="Bool"/>
</f></remove>
		<reverse public="1" line="171"><f a=""><e path="Void"/></f></reverse>
		<shift public="1" line="187"><f a=""><t path="Null"><c path="neko.NekoArray__.T"/></t></f></shift>
		<slice public="1" line="202"><f a="pos:?end">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><c path="neko.NekoArray__.T"/></c>
</f></slice>
		<sort public="1" line="219"><f a="f">
	<f a=":">
		<c path="neko.NekoArray__.T"/>
		<c path="neko.NekoArray__.T"/>
		<c path="Int"/>
	</f>
	<e path="Void"/>
</f></sort>
		<splice public="1" line="244"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><c path="neko.NekoArray__.T"/></c>
</f></splice>
		<__get line="269"><f a="pos">
	<c path="Int"/>
	<unknown/>
</f></__get>
		<__set line="273"><f a="pos:v">
	<c path="Int"/>
	<unknown/>
	<e path="Void"/>
</f></__set>
		<__double line="289"><f a="l">
	<c path="Int"/>
	<e path="Void"/>
</f></__double>
		<__neko line="306"><f a=""><unknown/></f></__neko>
		<new line="32"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="Reflect" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/Reflect.hx">
		<hasField public="1" line="35" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an object has a field set. This doesn't take into account the object prototype (class methods).
	</haxe_doc>
		</hasField>
		<field public="1" line="59" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Returns the field of an object, or null if [o] is not an object or doesn't have this field.
	</haxe_doc>
		</field>
		<setField public="1" line="83" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set an object field value.
	</haxe_doc>
		</setField>
		<callMethod public="1" line="99" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>
		Call a method with the given object and arguments.
	</haxe_doc>
		</callMethod>
		<fields public="1" line="123" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of fields of an object, excluding its prototype (class methods).
	</haxe_doc>
		</fields>
		<isFunction public="1" line="194" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is a function or not.
	</haxe_doc>
		</isFunction>
		<compare public="1" params="T" line="213" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Generic comparison function, does not work for methods, see [compareMethods]
	</haxe_doc>
		</compare>
		<compareMethods public="1" line="225" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Compare two methods closures. Returns true if it's the same method of the same instance.
		Does not work on Neko platform.
	</haxe_doc>
		</compareMethods>
		<isObject public="1" line="255" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is an object or not.

	</haxe_doc>
		</isObject>
		<deleteField public="1" line="294" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Delete an object field.
	</haxe_doc>
		</deleteField>
		<copy public="1" params="T" line="321" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>
		Make a copy of the fields of an object.
	</haxe_doc>
		</copy>
		<makeVarArgs public="1" line="339" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>
		Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.
	</haxe_doc>
		</makeVarArgs>
		<same_closure line="361" static="1"><f a=":">
	<d/>
	<d/>
	<e path="Bool"/>
</f></same_closure>
		<haxe_doc>
	The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.
</haxe_doc>
	</class>
	<class path="tests.std.XmlTest" params="" file="src/tests/std/XmlTest.hx">
		<testAtt public="1" line="155"><f a=""><e path="Void"/></f></testAtt>
		<testSpecials public="1" line="161"><f a=""><e path="Void"/></f></testSpecials>
		<new public="1" line="6"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.Log" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/haxe/Log.hx">
		<trace public="1" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" line="41" static="1"><f a=""><e path="Void"/></f></clear>
	</class>
	<class path="utest.Assert" params="" file="src/utest/Assert.hx">
		<results public="1" static="1"><c path="List"><e path="utest.Assertation"/></c></results>
		<isTrue public="1" line="8" static="1"><f a="cond:?msg:?pos">
	<e path="Bool"/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></isTrue>
		<isFalse public="1" line="16" static="1"><f a="value:?msg:?pos">
	<e path="Bool"/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></isFalse>
		<isNull public="1" line="20" static="1"><f a="value:?msg:?pos">
	<d/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></isNull>
		<notNull public="1" line="25" static="1"><f a="value:?msg:?pos">
	<d/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></notNull>
		<is public="1" line="29" static="1"><f a="value:type:?msg:?pos">
	<d/>
	<d/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></is>
		<equals public="1" line="34" static="1"><f a="expected:value:?msg:?pos">
	<d/>
	<d/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></equals>
		<floatEquals public="1" line="39" static="1"><f a="expected:value:?msg:?pos">
	<c path="Float"/>
	<c path="Float"/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></floatEquals>
		<getTypeName line="44" static="1"><f a="v">
	<d/>
	<c path="String"/>
</f></getTypeName>
		<isIterable line="61" static="1"><f a="v:isAnonym">
	<d/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></isIterable>
		<isIterator line="67" static="1"><f a="v:isAnonym">
	<d/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></isIterator>
		<sameAs line="73" static="1"><f a="expected:value:status">
	<d/>
	<d/>
	<t path="utest._Assert.LikeStatus"/>
	<e path="Bool"/>
</f></sameAs>
		<same public="1" line="241" static="1">
			<f a="expected:value:?recursive:?msg:?pos">
				<d/>
				<d/>
				<e path="Bool"/>
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	* Check that value is an object with the same fields and values found in expected.
	* The default behavior is to check nested objects in fields recursively.
	</haxe_doc>
		</same>
		<raises public="1" line="250" static="1"><f a="method:type:?msg:?pos">
	<f a=""><e path="Void"/></f>
	<c path="Class"><d/></c>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></raises>
		<allows public="1" params="T" line="259" static="1"><f a="possibilities:value:?msg:?pos">
	<c path="Array"><c path="allows.T"/></c>
	<c path="allows.T"/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></allows>
		<contains public="1" params="T" line="267" static="1"><f a="match:values:?msg:?pos">
	<c path="contains.T"/>
	<c path="Array"><c path="contains.T"/></c>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></contains>
		<fail public="1" line="275" static="1"><f a="?msg:?pos">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></fail>
		<warn public="1" line="279" static="1"><f a="msg">
	<c path="String"/>
	<e path="Void"/>
</f></warn>
		<createAsync public="1" line="283" static="1"><f a="f:?timeout">
	<f a=""><e path="Void"/></f>
	<c path="Int"/>
	<f a=""><e path="Void"/></f>
</f></createAsync>
		<createEvent public="1" params="EventArg" line="286" static="1"><f a="f:?timeout">
	<f a="">
		<c path="createEvent.EventArg"/>
		<e path="Void"/>
	</f>
	<c path="Int"/>
	<f a="e">
		<unknown/>
		<e path="Void"/>
	</f>
</f></createEvent>
	</class>
	<typedef path="utest._Assert.LikeStatus" params="" file="src/utest/Assert.hx" private="1" module="utest.Assert"><a>
	<recursive><e path="Bool"/></recursive>
	<path><c path="String"/></path>
	<error><c path="String"/></error>
</a></typedef>
	<class path="StringBuf" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/StringBuf.hx">
		<__make line="115" static="1"><d/></__make>
		<__add line="116" static="1"><d/></__add>
		<__add_char line="117" static="1"><d/></__add_char>
		<__add_sub line="118" static="1"><d/></__add_sub>
		<__string line="119" static="1"><d/></__string>
		<add public="1" line="48">
			<f a="?x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the representation of any value to the string buffer.
	</haxe_doc>
		</add>
		<addSub public="1" line="61">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a part of a string to the string buffer.
	</haxe_doc>
		</addSub>
		<addChar public="1" line="79">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a character to the string buffer.
	</haxe_doc>
		</addChar>
		<toString public="1" line="95">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the content of the string buffer.
		The buffer is not emptied by this operation.
	</haxe_doc>
		</toString>
		<b><d/></b>
		<new public="1" line="35">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new string buffer.
	</haxe_doc>
		</new>
		<haxe_doc>
	A String buffer is an efficient way to build a big string by
	appending small elements together.
</haxe_doc>
	</class>
	<class path="utest.TestResult" params="" file="src/utest/TestResult.hx">
		<ofHandler public="1" line="15" static="1"><f a="handler">
	<c path="utest.TestHandler"><d/></c>
	<c path="utest.TestResult"/>
</f></ofHandler>
		<pack public="1"><c path="String"/></pack>
		<cls public="1"><c path="String"/></cls>
		<method public="1"><c path="String"/></method>
		<setup public="1"><c path="String"/></setup>
		<teardown public="1"><c path="String"/></teardown>
		<assertations public="1"><c path="List"><e path="utest.Assertation"/></c></assertations>
		<new public="1" line="13"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="utest.ui.common.ResultStats" params="" file="src/utest/ui/common/ResultStats.hx">
		<assertations public="1" set="null"><c path="Int"/></assertations>
		<successes public="1" set="null"><c path="Int"/></successes>
		<failures public="1" set="null"><c path="Int"/></failures>
		<errors public="1" set="null"><c path="Int"/></errors>
		<warnings public="1" set="null"><c path="Int"/></warnings>
		<onAddSuccesses public="1" set="null"><c path="utest.Dispatcher"><c path="Int"/></c></onAddSuccesses>
		<onAddFailures public="1" set="null"><c path="utest.Dispatcher"><c path="Int"/></c></onAddFailures>
		<onAddErrors public="1" set="null"><c path="utest.Dispatcher"><c path="Int"/></c></onAddErrors>
		<onAddWarnings public="1" set="null"><c path="utest.Dispatcher"><c path="Int"/></c></onAddWarnings>
		<isOk public="1" set="null"><e path="Bool"/></isOk>
		<hasFailures public="1" set="null"><e path="Bool"/></hasFailures>
		<hasErrors public="1" set="null"><e path="Bool"/></hasErrors>
		<hasWarnings public="1" set="null"><e path="Bool"/></hasWarnings>
		<addSuccesses public="1" line="39"><f a="v">
	<c path="Int"/>
	<e path="Void"/>
</f></addSuccesses>
		<addFailures public="1" line="46"><f a="v">
	<c path="Int"/>
	<e path="Void"/>
</f></addFailures>
		<addErrors public="1" line="55"><f a="v">
	<c path="Int"/>
	<e path="Void"/>
</f></addErrors>
		<addWarnings public="1" line="64"><f a="v">
	<c path="Int"/>
	<e path="Void"/>
</f></addWarnings>
		<sum public="1" line="73"><f a="other">
	<c path="utest.ui.common.ResultStats"/>
	<e path="Void"/>
</f></sum>
		<subtract public="1" line="80"><f a="other">
	<c path="utest.ui.common.ResultStats"/>
	<e path="Void"/>
</f></subtract>
		<wire public="1" line="87"><f a="dependant">
	<c path="utest.ui.common.ResultStats"/>
	<e path="Void"/>
</f></wire>
		<unwire public="1" line="95"><f a="dependant">
	<c path="utest.ui.common.ResultStats"/>
	<e path="Void"/>
</f></unwire>
		<new public="1" line="21"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="utest.ui.text.TraceReport" params="" file="src/utest/ui/text/TraceReport.hx">
		<aggregator><c path="utest.ui.common.ResultAggregator"/></aggregator>
		<newline><c path="String"/></newline>
		<indent><c path="String"/></indent>
		<startTime><c path="Float"/></startTime>
		<start line="42"><f a="e">
	<c path="utest.Runner"/>
	<e path="Void"/>
</f></start>
		<indents line="46"><f a="c">
	<c path="Int"/>
	<c path="String"/>
</f></indents>
		<complete line="53"><f a="result">
	<c path="utest.ui.common.PackageResult"/>
	<e path="Void"/>
</f></complete>
		<new public="1" line="15"><f a="runner">
	<c path="utest.Runner"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="utest.ui.common.ResultAggregator" params="" file="src/utest/ui/common/ResultAggregator.hx">
		<runner><c path="utest.Runner"/></runner>
		<flattenPackage><e path="Bool"/></flattenPackage>
		<root public="1" set="null"><c path="utest.ui.common.PackageResult"/></root>
		<onStart public="1" set="null"><c path="utest.Notifier"/></onStart>
		<onComplete public="1" set="null"><c path="utest.Dispatcher"><c path="utest.ui.common.PackageResult"/></c></onComplete>
		<onProgress public="1" set="null"><c path="utest.Dispatcher"><a>
	<totals><c path="Int"/></totals>
	<done><c path="Int"/></done>
</a></c></onProgress>
		<start line="32"><f a="runner">
	<c path="utest.Runner"/>
	<e path="Void"/>
</f></start>
		<getOrCreatePackage line="37"><f a="pack:flat:?ref">
	<c path="String"/>
	<e path="Bool"/>
	<c path="utest.ui.common.PackageResult"/>
	<c path="utest.ui.common.PackageResult"/>
</f></getOrCreatePackage>
		<getOrCreateClass line="55"><f a="pack:cls:setup:teardown">
	<c path="utest.ui.common.PackageResult"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<t path="Null"><c path="utest.ui.common.ClassResult"/></t>
</f></getOrCreateClass>
		<createFixture line="62"><f a="result">
	<c path="utest.TestResult"/>
	<c path="utest.ui.common.FixtureResult"/>
</f></createFixture>
		<progress line="69"><f a="e">
	<a>
		<totals><c path="Int"/></totals>
		<result><c path="utest.TestResult"/></result>
		<done><c path="Int"/></done>
	</a>
	<e path="Void"/>
</f></progress>
		<complete line="74"><f a="runner">
	<c path="utest.Runner"/>
	<e path="Void"/>
</f></complete>
		<new public="1" line="19"><f a="runner:?flattenPackage">
	<c path="utest.Runner"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Date" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/Date.hx" extern="1">
		<now public="1" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>
		Returns a Date representing the current local time.
	</haxe_doc>
		</now>
		<fromTime public="1" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a timestamp [t] which is the number of
		milliseconds elapsed since 1st January 1970.
	</haxe_doc>
		</fromTime>
		<fromString public="1" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a formated string of one of the following formats :
		[YYYY-MM-DD hh:mm:ss] or [YYYY-MM-DD] or [hh:mm:ss]. The first two formats
		are expressed in local time, the third in UTC Epoch.
	</haxe_doc>
		</fromString>
		<getTime public="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
		Returns the timestamp of the date. It's the number of milliseconds
		elapsed since 1st January 1970. It might only have a per-second precision
		depending on the platforms.
	</haxe_doc>
		</getTime>
		<getHours public="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the hours value of the date (0-23 range).
	</haxe_doc>
		</getHours>
		<getMinutes public="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the minutes value of the date (0-59 range).
	</haxe_doc>
		</getMinutes>
		<getSeconds public="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the seconds of the date (0-59 range).
	</haxe_doc>
		</getSeconds>
		<getFullYear public="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the full year of the date.
	</haxe_doc>
		</getFullYear>
		<getMonth public="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the month of the date (0-11 range).
	</haxe_doc>
		</getMonth>
		<getDate public="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the day of the date (1-31 range).
	</haxe_doc>
		</getDate>
		<getDay public="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the week day of the date (0-6 range).
	</haxe_doc>
		</getDay>
		<toString public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a string representation for the Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See [DateTools.format] for
		other formating rules.
	</haxe_doc>
		</toString>
		<new public="1">
			<f a="year:month:day:hour:min:sec">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a new date object.
	</haxe_doc>
		</new>
		<haxe_doc>
	The Date class is used for date manipulation. There is some extra functions
	available in the [DateTools] class.
</haxe_doc>
	</class>
	<class path="haxe.io.Bytes" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" line="199" static="1"><f a="length">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" line="223" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" line="258" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<length public="1" set="null"><c path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<get public="1" line="37"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<set public="1" line="49"><f a="pos:v">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></set>
		<blit public="1" line="61"><f a="pos:src:srcpos:len">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></blit>
		<sub public="1" line="89"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<compare public="1" line="108"><f a="other">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
</f></compare>
		<readString public="1" line="140"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<toString public="1" line="180"><f a=""><c path="String"/></f></toString>
		<getData public="1" line="195"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<new line="32"><f a="length:b">
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="String" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/String.hx" extern="1">
		<fromCharCode public="1" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of characters in the String.
	</haxe_doc>
		</length>
		<toUpperCase public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been uppercased.
	</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been lowercased.
	</haxe_doc>
		</toLowerCase>
		<charAt public="1">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the character at the given position.
		Returns the empty String if outside of String bounds.
	</haxe_doc>
		</charAt>
		<charCodeAt public="1">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Returns the character code at the given position.
		Returns [null] if outside of String bounds.
	</haxe_doc>
		</charCodeAt>
		<indexOf public="1">
			<f a="value:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.
	</haxe_doc>
		</indexOf>
		<lastIndexOf public="1">
			<f a="value:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Similar to [indexOf] but returns the latest index.
	</haxe_doc>
		</lastIndexOf>
		<split public="1">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split the string using the specified delimiter.
	</haxe_doc>
		</split>
		<substr public="1">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.
	</haxe_doc>
		</substr>
		<toString public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the String itself.
	</haxe_doc>
		</toString>
		<new public="1">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a copy from a given String.
	</haxe_doc>
		</new>
		<haxe_doc>
	The basic String class.
</haxe_doc>
	</class>
	<class path="neko.NekoString__" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/neko/NekoString__.hx">
		<implements path="String"/>
		<__name__ line="29" static="1"><c path="Array"><c path="String"/></c></__name__>
		<__split line="30" static="1"><d/></__split>
		<fromCharCode line="177" static="1"><f a="c">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<length public="1" set="null"><c path="Int"/></length>
		<charAt public="1" line="43"><f a="p">
	<c path="Int"/>
	<c path="String"/>
</f></charAt>
		<charCodeAt public="1" line="55"><f a="p">
	<c path="Int"/>
	<t path="Null"><c path="Int"/></t>
</f></charCodeAt>
		<indexOf public="1" line="61"><f a="str:?pos">
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
</f></indexOf>
		<lastIndexOf public="1" line="70"><f a="str:?pos">
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
</f></lastIndexOf>
		<split public="1" line="85"><f a="delim">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></split>
		<substr public="1" line="101"><f a="pos:?len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></substr>
		<toLowerCase public="1" line="127"><f a=""><c path="String"/></f></toLowerCase>
		<toUpperCase public="1" line="143"><f a=""><c path="String"/></f></toUpperCase>
		<toString public="1" line="159"><f a=""><c path="String"/></f></toString>
		<__compare line="165"><f a="o">
	<a><__s><unknown/></__s></a>
	<unknown/>
</f></__compare>
		<__add line="169"><f a="s">
	<unknown/>
	<c path="String"/>
</f></__add>
		<__radd line="173"><f a="s">
	<unknown/>
	<c path="String"/>
</f></__radd>
		<new line="34"><f a="s">
	<unknown/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="IntIter" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/IntIter.hx">
		<min><c path="Int"/></min>
		<max><c path="Int"/></max>
		<hasNext public="1" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Returns true if the iterator has other items, false otherwise.
	</haxe_doc>
		</hasNext>
		<next public="1" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Moves to the next item of the iterator.
	</haxe_doc>
		</next>
		<new public="1" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.
	]]></haxe_doc>
		</new>
		<haxe_doc>
	Integer iterator. Used for interval implementation.
</haxe_doc>
	</class>
	<class path="haxe.Timer" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/haxe/Timer.hx"><stamp public="1" line="89" static="1">
	<f a=""><c path="Float"/></f>
	<haxe_doc>
		Returns a timestamp, in seconds
	</haxe_doc>
</stamp></class>
	<class path="utest.Runner" params="" file="src/utest/Runner.hx">
		<fixtures set="null"><c path="Array"><c path="utest.TestFixture"><d/></c></c></fixtures>
		<onProgress public="1" set="null">
			<c path="utest.Dispatcher"><a>
	<totals><c path="Int"/></totals>
	<result><c path="utest.TestResult"/></result>
	<done><c path="Int"/></done>
</a></c>
			<haxe_doc>
	* Event object that monitors the progress of the runner.
	</haxe_doc>
		</onProgress>
		<onStart public="1" set="null">
			<c path="utest.Dispatcher"><c path="utest.Runner"/></c>
			<haxe_doc>
	* Event object that monitors when the runner starts.
	</haxe_doc>
		</onStart>
		<onComplete public="1" set="null">
			<c path="utest.Dispatcher"><c path="utest.Runner"/></c>
			<haxe_doc>
	* Event object that monitors when the runner ends. This event takes into account async calls
	* performed during the tests.
	</haxe_doc>
		</onComplete>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
	* The number of fixtures registered.
	</haxe_doc>
		</length>
		<addCase public="1" line="51">
			<f a="test:?setup:?teardown:?prefix:?pattern">
				<d/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="EReg"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	* Adds a new test case.
	* @param	test: must be a not null object
	* @param	setup: string name of the setup function (defaults to "setup")
	* @param	teardown: string name of the teardown function (defaults to "teardown")
	* @param	prefix: prefix for methods that are tests (defaults to "test")
	* @param	pattern: a regular expression that discriminates the names of test
	* 			functions; when set,  the prefix parameter is meaningless
	</haxe_doc>
		</addCase>
		<addFixture public="1" line="73"><f a="fixture">
	<c path="utest.TestFixture"><d/></c>
	<e path="Void"/>
</f></addFixture>
		<getFixture public="1" line="78"><f a="index">
	<c path="Int"/>
	<c path="utest.TestFixture"><d/></c>
</f></getFixture>
		<isMethod line="82"><f a="test:name">
	<d/>
	<c path="String"/>
	<e path="Bool"/>
</f></isMethod>
		<pos><c path="Int"/></pos>
		<run public="1" line="91"><f a=""><e path="Void"/></f></run>
		<runNext line="97"><f a=""><e path="Void"/></f></runNext>
		<runFixture line="104"><f a="fixture">
	<c path="utest.TestFixture"><d/></c>
	<e path="Void"/>
</f></runFixture>
		<testComplete line="110"><f a="h">
	<c path="utest.TestHandler"><d/></c>
	<e path="Void"/>
</f></testComplete>
		<new public="1" line="34">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	* Instantiates a Runner onject.
	</haxe_doc>
		</new>
		<haxe_doc>
* The Runner class performs a set of tests. The tests can be added using addCase or addFixtures.
* Once all the tests are register they are axecuted on the run() call.
* Note that Runner does not provide any visual output. To visualize the test results use one of
* the classes in the utest.ui package.
</haxe_doc>
	</class>
	<enum path="haxe.io.Error" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/haxe/io/Error.hx">
		<Overflow><haxe_doc> An integer value is outside its allowed range </haxe_doc></Overflow>
		<OutsideBounds><haxe_doc> An operation on Bytes is outside of its valid range </haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc> Other errors </haxe_doc>
		</Custom>
		<Blocked><haxe_doc> The IO is set into nonblocking mode and some data cannot be read or written </haxe_doc></Blocked>
		<haxe_doc>
	The possible IO errors that can occur
</haxe_doc>
	</enum>
	<class path="neko.Web" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/neko/Web.hx">
		<getParams public="1" line="36" static="1">
			<f a=""><c path="Hash"><c path="String"/></c></f>
			<haxe_doc>
		Returns the GET and POST parameters.
	</haxe_doc>
		</getParams>
		<getParamValues public="1" line="53" static="1">
			<f a="param">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns an Array of Strings built using GET / POST values.
		If you have in your URL the parameters [a[]=foo;a[]=hello;a[5]=bar;a[3]=baz] then
		[neko.Web.getParamValues("a")] will return [["foo","hello",null,"baz",null,"bar"]]
	</haxe_doc>
		</getParamValues>
		<getHostName public="1" line="80" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the local server host name
	</haxe_doc>
		</getHostName>
		<getClientIP public="1" line="87" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Surprisingly returns the client IP address.
	</haxe_doc>
		</getClientIP>
		<getURI public="1" line="94" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the original request URL (before any server internal redirections)
	</haxe_doc>
		</getURI>
		<redirect public="1" line="101" static="1">
			<f a="url">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Tell the client to redirect to the given url ("Location" header)
	</haxe_doc>
		</redirect>
		<setHeader public="1" line="109" static="1">
			<f a="h:v">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set an output header value. If some data have been printed, the headers have
		already been sent so this will raise an exception.
	</haxe_doc>
		</setHeader>
		<setReturnCode public="1" line="116" static="1">
			<f a="r">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set the HTTP return code. Same remark as setHeader.
	</haxe_doc>
		</setReturnCode>
		<getClientHeader public="1" line="123" static="1">
			<f a="k">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Retrieve a client header value sent with the request.
	</haxe_doc>
		</getClientHeader>
		<getClientHeaders public="1" line="133" static="1">
			<f a=""><c path="List"><a>
	<value><c path="String"/></value>
	<header><c path="String"/></header>
</a></c></f>
			<haxe_doc>
		Retrieve all the client headers.
	</haxe_doc>
		</getClientHeaders>
		<getParamsString public="1" line="146" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns all the GET parameters String
	</haxe_doc>
		</getParamsString>
		<getPostData public="1" line="158" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns all the POST data. POST Data is always parsed as
		being application/x-www-form-urlencoded and is stored into
		the getParams hashtable. POST Data is maximimized to 256K
		unless the content type is multipart/form-data. In that
		case, you will have to use [getMultipart] or [parseMultipart]
		methods.
	</haxe_doc>
		</getPostData>
		<getCookies public="1" line="169" static="1">
			<f a=""><c path="Hash"><c path="String"/></c></f>
			<haxe_doc>
		Returns an hashtable of all Cookies sent by the client.
		Modifying the hashtable will not modify the cookie, use setCookie instead.
	</haxe_doc>
		</getCookies>
		<setCookie public="1" line="185" static="1">
			<f a="key:value:?expire:?domain:?path:?secure">
				<c path="String"/>
				<c path="String"/>
				<c path="Date"/>
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a Cookie value in the HTTP headers. Same remark as setHeader.
	</haxe_doc>
		</setCookie>
		<addPair line="196" static="1"><f a="buf:name:value">
	<c path="StringBuf"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></addPair>
		<getAuthorization public="1" line="206" static="1">
			<f a=""><a>
	<user><c path="String"/></user>
	<pass><c path="String"/></pass>
</a></f>
			<haxe_doc>
		Returns an object with the authorization sent by the client (Basic scheme only).
	</haxe_doc>
		</getAuthorization>
		<getCwd public="1" line="224" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Get the current script directory in the local filesystem.
	</haxe_doc>
		</getCwd>
		<cacheModule public="1" line="232" static="1">
			<f a="f">
				<f a=""><e path="Void"/></f>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set the main entry point function used to handle requests.
		Setting it back to null will disable code caching.
	</haxe_doc>
		</cacheModule>
		<getMultipart public="1" line="240" static="1">
			<f a="maxSize">
				<c path="Int"/>
				<c path="Hash"><c path="String"/></c>
			</f>
			<haxe_doc>
		Get the multipart parameters as an hashtable. The data
		cannot exceed the maximum size specified.
	</haxe_doc>
		</getMultipart>
		<parseMultipart public="1" line="269" static="1">
			<f a="onPart:onData">
				<f a=":">
					<c path="String"/>
					<c path="String"/>
					<e path="Void"/>
				</f>
				<f a="::">
					<c path="haxe.io.Bytes"/>
					<c path="Int"/>
					<c path="Int"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Parse the multipart data. Call [onPart] when a new part is found
		with the part name and the filename if present
		and [onData] when some part data is readed. You can this way
		directly save the data on hard drive in the case of a file upload.
	</haxe_doc>
		</parseMultipart>
		<flush public="1" line="280" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Flush the data sent to the client. By default on Apache, outgoing data is buffered so
		this can be useful for displaying some long operation progress.
	</haxe_doc>
		</flush>
		<getMethod public="1" line="287" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Get the HTTP method used by the client. This api requires Neko 1.7.1+
	</haxe_doc>
		</getMethod>
		<logMessage public="1" line="294" static="1">
			<f a="msg">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Write a message into the web server log file. This api requires Neko 1.7.1+
	</haxe_doc>
		</logMessage>
		<isModNeko public="1" set="null" static="1"><e path="Bool"/></isModNeko>
		<_set_main static="1"><d/></_set_main>
		<_get_host_name static="1"><d/></_get_host_name>
		<_get_client_ip static="1"><d/></_get_client_ip>
		<_get_uri static="1"><d/></_get_uri>
		<_cgi_redirect static="1"><d/></_cgi_redirect>
		<_cgi_set_header static="1"><d/></_cgi_set_header>
		<_set_return_code static="1"><d/></_set_return_code>
		<_get_client_header static="1"><d/></_get_client_header>
		<_get_params_string static="1"><d/></_get_params_string>
		<_get_post_data static="1"><d/></_get_post_data>
		<_get_params static="1"><d/></_get_params>
		<_get_cookies static="1"><d/></_get_cookies>
		<_set_cookie static="1"><d/></_set_cookie>
		<_get_cwd static="1"><d/></_get_cwd>
		<_parse_multipart static="1"><d/></_parse_multipart>
		<_flush static="1"><d/></_flush>
		<_get_client_headers static="1"><d/></_get_client_headers>
		<_get_http_method static="1"><d/></_get_http_method>
		<_base_decode line="318" static="1"><f a=":">
	<unknown/>
	<unknown/>
	<c path="String"/>
</f></_base_decode>
		<_log_message static="1"><d/></_log_message>
		<haxe_doc>
	This class is used for accessing the local Web server and the current
	client request and informations.
</haxe_doc>
	</class>
	<class path="Float" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	The standard Float type, this is a double-precision IEEE 64bit float.
</haxe_doc></class>
	<class path="Int" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>
	The standard Int type. Its precision depends on the platform.
</haxe_doc>
	</class>
	<enum path="Bool" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>
	The standard Boolean type is represented as an enum with two choices.
</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="C:\Programmi\Motion-Twin\haxe\haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.
</haxe_doc></class>
	<class path="Class" params="T" file="C:\Programmi\Motion-Twin\haxe\haxe/std/Class.hx" extern="1"><haxe_doc>
	An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<enum path="Void" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>
	The standard Void type. Only [null] values can be of the type [Void].
</haxe_doc></enum>
	<class path="Std" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/Std.hx">
		<is public="1" line="34" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value v is of the type t.
	</haxe_doc>
		</is>
		<string public="1" line="52" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Convert any value to a String
	</haxe_doc>
		</string>
		<int public="1" line="70" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Convert a Float to an Int, rounded down.
	</haxe_doc>
		</int>
		<parseInt public="1" line="84" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.
	</haxe_doc>
		</parseInt>
		<parseFloat public="1" line="122" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a String to a Float, parsing different possible reprensations.
	</haxe_doc>
		</parseFloat>
		<random public="1" line="142" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Return a random integer between 0 included and x excluded.
	</haxe_doc>
		</random>
		<haxe_doc>
	The Std class provides standard methods for manipulating basic types.
</haxe_doc>
	</class>
	<typedef path="Null" params="T" file="C:\Programmi\Motion-Twin\haxe\haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>
	[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.
</haxe_doc>
	</typedef>
	<typedef path="Iterator" params="T" file="C:\Programmi\Motion-Twin\haxe\haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next><f a=""><c path="Iterator.T"/></f></next>
			<hasNext><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>
	An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.
</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="C:\Programmi\Motion-Twin\haxe\haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>
	An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.
</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="C:\Programmi\Motion-Twin\haxe\haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>
	ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.
</haxe_doc></class>
	<class path="Lambda" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/Lambda.hx">
		<array public="1" params="A" line="35" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>
		Creates an [Array] from an [Iterable]
	</haxe_doc>
		</array>
		<list public="1" params="A" line="45" static="1">
			<f a="it">
				<t path="Iterable"><c path="list.A"/></t>
				<c path="List"><c path="list.A"/></c>
			</f>
			<haxe_doc>
		Creates a [List] from an [Iterable]
	</haxe_doc>
		</list>
		<map public="1" params="A:B" line="56" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="map.A"/></t>
				<f a="">
					<c path="map.A"/>
					<c path="map.B"/>
				</f>
				<c path="List"><c path="map.B"/></c>
			</f>
			<haxe_doc>
		Creates a new [Iterable] by appling the function 'f' to all
		elements of the iterator 'it'.
	</haxe_doc>
		</map>
		<mapi public="1" params="A:B" line="66" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="mapi.A"/></t>
				<f a=":">
					<c path="Int"/>
					<c path="mapi.A"/>
					<c path="mapi.B"/>
				</f>
				<c path="List"><c path="mapi.B"/></c>
			</f>
			<haxe_doc>
		Similar to [map], but also pass an index for each item iterated.
	</haxe_doc>
		</mapi>
		<has public="1" params="A" line="81" static="1">
			<f a="it:elt:?cmp">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<f a=":">
					<c path="has.A"/>
					<c path="has.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the element is part of an iterable. The comparison
		is made using the [==] operator. Optionally you can pass as
		a third parameter a function that performs the comparison.
		That function must take as arguments the two items to
		compare and returns a boolean value.
	</haxe_doc>
		</has>
		<exists public="1" params="A" line="97" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="">
					<c path="exists.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if at least one element of the iterable is found by using the specific function.
	</haxe_doc>
		</exists>
		<foreach public="1" params="A" line="107" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="foreach.A"/></t>
				<f a="">
					<c path="foreach.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if all elements of the iterable have the specified property defined by [f].
	</haxe_doc>
		</foreach>
		<iter public="1" params="A" line="117" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="iter.A"/></t>
				<f a="">
					<c path="iter.A"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Call the function 'f' on all elements of the [Iterable] 'it'.
	</haxe_doc>
		</iter>
		<filter public="1" params="A" line="125" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="">
					<c path="filter.A"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="filter.A"/></c>
			</f>
			<haxe_doc>
		Return the list of elements matching the function 'f'
	</haxe_doc>
		</filter>
		<fold public="1" params="A:B" line="136" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="fold.A"/></t>
				<f a=":">
					<c path="fold.A"/>
					<c path="fold.B"/>
					<c path="fold.B"/>
				</f>
				<c path="fold.B"/>
				<c path="fold.B"/>
			</f>
			<haxe_doc>
		Functional 'fold' using an [Iterable]
	</haxe_doc>
		</fold>
		<count public="1" params="A" line="145" static="1">
			<f a="it">
				<t path="Iterable"><c path="count.A"/></t>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Count the number of elements in an [Iterable]
	</haxe_doc>
		</count>
		<empty public="1" line="155" static="1">
			<f a="it">
				<t path="Iterable"><d/></t>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an iterable does not contain any element.
	</haxe_doc>
		</empty>
		<haxe_doc>
	The [Lambda] class is a collection of functional methods in order to
	use functional-style programming with haXe.
</haxe_doc>
	</class>
	<class path="neko.NekoMath__" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/neko/NekoMath__.hx">
		<PI static="1"><unknown/></PI>
		<NaN static="1"><c path="Float"/></NaN>
		<POSITIVE_INFINITY static="1"><c path="Float"/></POSITIVE_INFINITY>
		<NEGATIVE_INFINITY static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<abs line="34" static="1"><unknown/></abs>
		<min line="35" static="1"><f a="a:b">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></min>
		<max line="36" static="1"><f a="a:b">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></max>
		<sin line="37" static="1"><unknown/></sin>
		<cos line="38" static="1"><unknown/></cos>
		<atan2 line="39" static="1"><unknown/></atan2>
		<tan line="40" static="1"><unknown/></tan>
		<exp line="41" static="1"><unknown/></exp>
		<log line="42" static="1"><unknown/></log>
		<sqrt line="43" static="1"><unknown/></sqrt>
		<round line="44" static="1"><unknown/></round>
		<floor line="45" static="1"><unknown/></floor>
		<ceil line="46" static="1"><unknown/></ceil>
		<atan line="47" static="1"><unknown/></atan>
		<asin line="48" static="1"><unknown/></asin>
		<acos line="49" static="1"><unknown/></acos>
		<pow line="50" static="1"><unknown/></pow>
		<__rnd static="1"><unknown/></__rnd>
		<_rand_float line="53" static="1"><f a="">
	<unknown/>
	<unknown/>
</f></_rand_float>
		<_rand_int line="54" static="1"><unknown/></_rand_int>
		<random line="55" static="1"><f a=""><unknown/></f></random>
		<isNaN line="57" static="1"><f a="f">
	<unknown/>
	<unknown/>
</f></isNaN>
		<isFinite line="58" static="1"><f a="f">
	<unknown/>
	<e path="Bool"/>
</f></isFinite>
	</class>
	<class path="Math" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" static="1"><f a="value1:value2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" static="1"><f a="value1:value2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" static="1"><f a="value1:value2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" static="1"><f a="value1:value2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>
	This class defines mathematical functions and constants.
</haxe_doc>
	</class>
	<class path="utest.ui.common.ClassResult" params="" file="src/utest/ui/common/ClassResult.hx">
		<fixtures><c path="Hash"><c path="utest.ui.common.FixtureResult"/></c></fixtures>
		<className public="1" set="null"><c path="String"/></className>
		<setupName public="1" set="null"><c path="String"/></setupName>
		<teardownName public="1" set="null"><c path="String"/></teardownName>
		<hasSetup public="1" set="null"><e path="Bool"/></hasSetup>
		<hasTeardown public="1" set="null"><e path="Bool"/></hasTeardown>
		<methods public="1" set="null"><c path="Int"/></methods>
		<stats public="1" set="null"><c path="utest.ui.common.ResultStats"/></stats>
		<add public="1" line="28"><f a="result">
	<c path="utest.ui.common.FixtureResult"/>
	<e path="Void"/>
</f></add>
		<get public="1" line="37"><f a="method">
	<c path="String"/>
	<t path="Null"><c path="utest.ui.common.FixtureResult"/></t>
</f></get>
		<exists public="1" line="41"><f a="method">
	<c path="String"/>
	<e path="Bool"/>
</f></exists>
		<methodNames public="1" line="45"><f a="?errorsHavePriority">
	<e path="Bool"/>
	<c path="Array"><c path="String"/></c>
</f></methodNames>
		<new public="1" line="16"><f a="className:setupName:teardownName">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="List" params="T" file="C:\Programmi\Motion-Twin\haxe\haxe/std/List.hx">
		<h><c path="Array"><d/></c></h>
		<q><c path="Array"><d/></c></q>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of elements in this list.
	</haxe_doc>
		</length>
		<add public="1" line="56">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add an element at the end of the list.
	</haxe_doc>
		</add>
		<push public="1" line="76">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Push an element at the beginning of the list.
	</haxe_doc>
		</push>
		<first public="1" line="100">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the first element of the list, or null
		if the list is empty.
	</haxe_doc>
		</first>
		<last public="1" line="108">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the last element of the list, or null
		if the list is empty.
	</haxe_doc>
		</last>
		<pop public="1" line="118">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.
	</haxe_doc>
		</pop>
		<isEmpty public="1" line="132">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Tells if a list is empty.
	</haxe_doc>
		</isEmpty>
		<clear public="1" line="139">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Makes the list empty.
	</haxe_doc>
		</clear>
		<remove public="1" line="149">
			<f a="v">
				<c path="List.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.
	</haxe_doc>
		</remove>
		<iterator public="1" line="190">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>
		Returns an iterator on the elements of the list.
	</haxe_doc>
		</iterator>
		<toString public="1" line="229">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the String.
	</haxe_doc>
		</toString>
		<join public="1" line="249">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Join the element of the list by using the separator [sep].
	</haxe_doc>
		</join>
		<filter public="1" line="268">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>
		Returns a list filtered with [f]. The returned list
		will contain all elements [x] for which [f(x) = true].
	</haxe_doc>
		</filter>
		<map public="1" params="X" line="284">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>
		Returns a new list where all elements have been converted
		by the function [f].
	</haxe_doc>
		</map>
		<new public="1" line="49">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty list.
	</haxe_doc>
		</new>
		<haxe_doc>
	A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.
</haxe_doc>
	</class>
	<enum path="ValueType" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"/></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
		<haxe_doc>
	The diffent possible runtime types of a value.
	See [Type] for the haXe Reflection API.
</haxe_doc>
	</enum>
	<class path="Type" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/Type.hx">
		<getClass public="1" params="T" line="26" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>
		Returns the class of a value or [null] if this value is not a Class instance.
	</haxe_doc>
		</getClass>
		<getEnum public="1" line="77" static="1">
			<f a="o">
				<d/>
				<c path="Enum"/>
			</f>
			<haxe_doc>
		Returns the enum of a value or [null] if this value is not an Enum instance.
	</haxe_doc>
		</getEnum>
		<getSuperClass public="1" line="113" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Returns the super-class of a class, or null if no super class.
	</haxe_doc>
		</getSuperClass>
		<getClassName public="1" line="134" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of a class.
	</haxe_doc>
		</getClassName>
		<getEnumName public="1" line="157" static="1">
			<f a="e">
				<c path="Enum"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of an enum.
	</haxe_doc>
		</getEnumName>
		<resolveClass public="1" line="172" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Evaluates a class from a name. The class must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" line="225" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"/>
			</f>
			<haxe_doc>
		Evaluates an enum from a name. The enum must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" line="273" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>
		Creates an instance of the given class with the list of constructor arguments.
	</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" line="315" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>
		Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.
	</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" line="369" static="1">
			<f a="e:constr:?params">
				<c path="Enum"/>
				<c path="String"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor name and parameters.
	</haxe_doc>
		</createEnum>
		<getInstanceFields public="1" line="400" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of instance fields.
	</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" line="447" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of a class static fields.
	</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" line="487" static="1">
			<f a="e">
				<c path="Enum"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns all the available constructor names for an enum.
	</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" line="506" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>
		Returns the runtime type of a value.
	</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" line="615" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Recursively compare two enums constructors and parameters.
	</haxe_doc>
		</enumEq>
		<enumConstructor public="1" line="670" static="1">
			<f a="e">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the constructor of an enum
	</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" line="683" static="1">
			<f a="e">
				<d/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>
		Returns the parameters of an enum
	</haxe_doc>
		</enumParameters>
		<enumIndex public="1" line="701" static="1">
			<f a="e">
				<d/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of the constructor of an enum
	</haxe_doc>
		</enumIndex>
		<haxe_doc>
	The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.
</haxe_doc>
	</class>
	<class path="IntHash" params="T" file="C:\Programmi\Motion-Twin\haxe\haxe/std/IntHash.hx">
		<h><d/></h>
		<set public="1" line="58">
			<f a="key:value">
				<c path="Int"/>
				<c path="IntHash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" line="71">
			<f a="key">
				<c path="Int"/>
				<t path="Null"><c path="IntHash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" line="91">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" line="111">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" line="138">
			<f a=""><t path="Iterator"><c path="Int"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" line="167">
			<f a=""><t path="Iterator"><c path="IntHash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" line="204">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" line="37">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty hashtable.
	</haxe_doc>
		</new>
		<haxe_doc>
	Hashtable over a set of elements, using [Int] as keys.
	On Flash and Javascript, the underlying structure is an Object.
</haxe_doc>
	</class>
	<class path="DateTools" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/DateTools.hx">
		<date_format line="36" static="1"><f a=":">
	<unknown/>
	<unknown/>
	<unknown/>
</f></date_format>
		<format public="1" line="116" static="1">
			<f a="d:f">
				<c path="Date"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Format the date [d] according to the format [f]. The format
		is compatible with the [strftime] standard format, except that there
		is no support in Flash and JS for day and months names (due to lack
		of proper internationalization API). On haXe/Neko/Windows, some
		formats are not supported.
	</haxe_doc>
		</format>
		<delta public="1" line="129" static="1">
			<f a="d:t">
				<c path="Date"/>
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date which time has been changed by [t] milliseconds.
	</haxe_doc>
		</delta>
		<DAYS_OF_MONTH line="133" static="1"><c path="Array"><c path="Int"/></c></DAYS_OF_MONTH>
		<getMonthDays public="1" line="138" static="1">
			<f a="d">
				<c path="Date"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the number of days in a month
	</haxe_doc>
		</getMonthDays>
		<seconds public="1" line="152" static="1">
			<f a="n">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a number of seconds to a date-time
	</haxe_doc>
		</seconds>
		<minutes public="1" line="159" static="1">
			<f a="n">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a number of minutes to a date-time
	</haxe_doc>
		</minutes>
		<hours public="1" line="166" static="1">
			<f a="n">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a number of hours to a date-time
	</haxe_doc>
		</hours>
		<days public="1" line="173" static="1">
			<f a="n">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a number of days to a date-time
	</haxe_doc>
		</days>
		<parse public="1" line="180" static="1">
			<f a="t">
				<c path="Float"/>
				<a>
					<seconds><c path="Int"/></seconds>
					<ms><c path="Float"/></ms>
					<minutes><c path="Int"/></minutes>
					<hours><c path="Int"/></hours>
					<days><c path="Int"/></days>
				</a>
			</f>
			<haxe_doc>
		Separate a date-time into several components
	</haxe_doc>
		</parse>
		<make public="1" line="196" static="1">
			<f a="o">
				<a>
					<seconds><c path="Int"/></seconds>
					<ms><c path="Float"/></ms>
					<minutes><c path="Int"/></minutes>
					<hours><c path="Int"/></hours>
					<days><c path="Int"/></days>
				</a>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Build a date-time from several components
	</haxe_doc>
		</make>
		<haxe_doc>
	The DateTools class contains some extra functionalities for [Date]
	manipulation. It's stored in a different class in order to prevent
	the standard [Date] of being bloated and thus increasing the size of
	each application using it.
</haxe_doc>
	</class>
	<enum path="utest.Assertation" params="" file="src/utest/Assertation.hx">
		<Warning a="msg"><c path="String"/></Warning>
		<TimeoutError a="missedAsyncs"><c path="Int"/></TimeoutError>
		<TeardownError a="e"><d/></TeardownError>
		<Success a="pos"><t path="haxe.PosInfos"/></Success>
		<SetupError a="e"><d/></SetupError>
		<Failure a="msg:pos">
			<c path="String"/>
			<t path="haxe.PosInfos"/>
		</Failure>
		<Error a="e"><d/></Error>
		<AsyncError a="e"><d/></AsyncError>
	</enum>
	<class path="EReg" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/EReg.hx">
		<regexp_new_options line="338" static="1"><f a=":">
	<unknown/>
	<unknown/>
	<unknown/>
</f></regexp_new_options>
		<regexp_match line="339" static="1"><f a=":::">
	<d/>
	<unknown/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></regexp_match>
		<regexp_matched line="340" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<c path="String"/>
</f></regexp_matched>
		<regexp_matched_pos line="341" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<a>
		<pos><c path="Int"/></pos>
		<len><c path="Int"/></len>
	</a>
</f></regexp_matched_pos>
		<r><d/></r>
		<last><c path="String"/></last>
		<global><e path="Bool"/></global>
		<match public="1" line="81">
			<f a="s">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the regular expression matches the String.
		Updates the internal state accordingly.
	</haxe_doc>
		</match>
		<matched public="1" line="117">
			<f a="n">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a matched group or throw an expection if there
		is no such group. If [n = 0], the whole matched substring
		is returned.
	</haxe_doc>
		</matched>
		<matchedLeft public="1" line="141">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the part of the string that was as the left of
		of the matched substring.
	</haxe_doc>
		</matchedLeft>
		<matchedRight public="1" line="167">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the part of the string that was at the right of
		of the matched substring.
	</haxe_doc>
		</matchedRight>
		<matchedPos public="1" line="199">
			<f a=""><a>
	<pos><c path="Int"/></pos>
	<len><c path="Int"/></len>
</a></f>
			<haxe_doc>
		Returns the position of the matched substring within the
		original matched string.
	</haxe_doc>
		</matchedPos>
		<split public="1" line="219">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split a string by using the regular expression to match
		the separators.
	</haxe_doc>
		</split>
		<replace public="1" line="258">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replaces a pattern by another string. The [by] format can
		contains [$1] to [$9] that will correspond to groups matched
		while replacing. [$$] means the [$] character.
	</haxe_doc>
		</replace>
		<customReplace public="1" line="324">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>
		For each occurence of the pattern in the string [s], the function [f] is called and
		can return the string that needs to be replaced. All occurences are matched anyway,
		and setting the [g] flag might cause some incorrect behavior on some platforms.
	</haxe_doc>
		</customReplace>
		<new public="1" line="52">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a new regular expression with pattern [r] and
		options [opt].
	</haxe_doc>
		</new>
		<haxe_doc>
	Regular expressions are a way to find regular patterns into
	Strings. Have a look at the tutorial on haXe website to learn
	how to use them.
</haxe_doc>
	</class>
	<class path="utest.ui.common.FixtureResult" params="" file="src/utest/ui/common/FixtureResult.hx">
		<methodName public="1" set="null"><c path="String"/></methodName>
		<hasTestError public="1" set="null"><e path="Bool"/></hasTestError>
		<hasSetupError public="1" set="null"><e path="Bool"/></hasSetupError>
		<hasTeardownError public="1" set="null"><e path="Bool"/></hasTeardownError>
		<hasTimeoutError public="1" set="null"><e path="Bool"/></hasTimeoutError>
		<hasAsyncError public="1" set="null"><e path="Bool"/></hasAsyncError>
		<stats public="1" set="null"><c path="utest.ui.common.ResultStats"/></stats>
		<list set="null"><c path="List"><e path="utest.Assertation"/></c></list>
		<iterator public="1" line="28"><f a=""><t path="Iterator"><e path="utest.Assertation"/></t></f></iterator>
		<add public="1" line="32"><f a="assertation">
	<e path="utest.Assertation"/>
	<e path="Void"/>
</f></add>
		<new public="1" line="16"><f a="methodName">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="utest._Dispatcher.EventException" params="" file="src/utest/Dispatcher.hx" private="1" module="utest.Dispatcher"><StopPropagation/></enum>
	<class path="utest.Dispatcher" params="T" file="src/utest/Dispatcher.hx">
		<stop public="1" line="47" static="1"><f a=""><e path="Void"/></f></stop>
		<handlers><c path="Array"><f a="">
	<c path="utest.Dispatcher.T"/>
	<e path="Void"/>
</f></c></handlers>
		<add public="1" line="15"><f a="h">
	<f a="">
		<c path="utest.Dispatcher.T"/>
		<e path="Void"/>
	</f>
	<f a="">
		<c path="utest.Dispatcher.T"/>
		<e path="Void"/>
	</f>
</f></add>
		<remove public="1" line="20"><f a="h">
	<f a="">
		<c path="utest.Dispatcher.T"/>
		<e path="Void"/>
	</f>
	<f a="">
		<c path="utest.Dispatcher.T"/>
		<e path="Void"/>
	</f>
</f></remove>
		<clear public="1" line="27"><f a=""><e path="Void"/></f></clear>
		<dispatch public="1" line="31"><f a="e">
	<c path="utest.Dispatcher.T"/>
	<e path="Bool"/>
</f></dispatch>
		<has public="1" line="43"><f a=""><e path="Bool"/></f></has>
		<new public="1" line="11"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="utest.Notifier" params="" file="src/utest/Dispatcher.hx" module="utest.Dispatcher">
		<stop public="1" line="92" static="1"><f a=""><e path="Void"/></f></stop>
		<handlers><c path="Array"><f a=""><e path="Void"/></f></c></handlers>
		<add public="1" line="60"><f a="h">
	<f a=""><e path="Void"/></f>
	<f a=""><e path="Void"/></f>
</f></add>
		<remove public="1" line="65"><f a="h">
	<f a=""><e path="Void"/></f>
	<f a=""><e path="Void"/></f>
</f></remove>
		<clear public="1" line="72"><f a=""><e path="Void"/></f></clear>
		<dispatch public="1" line="76"><f a=""><e path="Bool"/></f></dispatch>
		<has public="1" line="88"><f a=""><e path="Bool"/></f></has>
		<new public="1" line="56"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="neko.NativeString" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/neko/NativeString.hx">
		<ofString public="1" line="29" static="1"><f a="s">
	<c path="String"/>
	<c path="neko.NativeString"/>
</f></ofString>
		<toString public="1" line="33" static="1"><f a="s">
	<c path="neko.NativeString"/>
	<c path="String"/>
</f></toString>
		<length public="1" line="37" static="1"><f a="s">
	<c path="neko.NativeString"/>
	<c path="Int"/>
</f></length>
	</class>
	<typedef path="haxe.PosInfos" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams><c path="Array"><d/></c></customParams>
	<className><c path="String"/></className>
</a></typedef>
	<class path="utest.TestHandler" params="T" file="src/utest/TestHandler.hx">
		<POLLING_TIME line="6" static="1"><c path="Int"/></POLLING_TIME>
		<results public="1" set="null"><c path="List"><e path="utest.Assertation"/></c></results>
		<fixture public="1" set="null"><c path="utest.TestFixture"><c path="utest.TestHandler.T"/></c></fixture>
		<asyncStack><c path="List"><d/></c></asyncStack>
		<onTested public="1" set="null"><c path="utest.Dispatcher"><c path="utest.TestHandler"><c path="utest.TestHandler.T"/></c></c></onTested>
		<onTimeout public="1" set="null"><c path="utest.Dispatcher"><c path="utest.TestHandler"><c path="utest.TestHandler.T"/></c></c></onTimeout>
		<onComplete public="1" set="null"><c path="utest.Dispatcher"><c path="utest.TestHandler"><c path="utest.TestHandler.T"/></c></c></onComplete>
		<execute public="1" line="25"><f a=""><e path="Void"/></f></execute>
		<checkTested line="39"><f a=""><e path="Void"/></f></checkTested>
		<expireson public="1" set="null"><t path="Null"><c path="Float"/></t></expireson>
		<setTimeout public="1" line="57"><f a="timeout">
	<c path="Int"/>
	<e path="Void"/>
</f></setTimeout>
		<bindHandler line="62"><f a=""><e path="Void"/></f></bindHandler>
		<unbindHandler line="68"><f a=""><e path="Void"/></f></unbindHandler>
		<addAsync public="1" line="98">
			<f a="f:?timeout">
				<f a=""><e path="Void"/></f>
				<c path="Int"/>
				<f a=""><e path="Void"/></f>
			</f>
			<haxe_doc><![CDATA[
	* Adds a function that is called asynchronously.
	*
	* Example:
	* <pre>
	* var fixture = new TestFixture(new TestClass(), "test");
	* var handler = new TestHandler(fixture);
	* var flag = false;
	* var async = handler.addAsync(function() {
	*   flag = true;
	* }, 50);
	* handler.onTimeout.add(function(h) {
	*  trace("TIMEOUT");
	* });
	* handler.onTested.add(function(h) {
	*   trace(flag ? "OK" : "FAILED");
	* });
	* haxe.Timer.delay(function() async(), 10);
	* handler.execute();
	* </pre>
	* @param	f, the function that is called asynchrnously
	* @param	timeout, the maximum time to wait for f() (default is 250)
	* @return	returns a function closure that must be executed asynchrnously
	]]></haxe_doc>
		</addAsync>
		<addEvent public="1" params="EventArg" line="116"><f a="f:?timeout">
	<f a="">
		<c path="addEvent.EventArg"/>
		<e path="Void"/>
	</f>
	<c path="Int"/>
	<f a="e">
		<c path="addEvent.EventArg"/>
		<e path="Void"/>
	</f>
</f></addEvent>
		<executeMethod line="134"><f a="name">
	<c path="String"/>
	<e path="Void"/>
</f></executeMethod>
		<tested line="140"><f a=""><e path="Void"/></f></tested>
		<timeout line="147"><f a=""><e path="Void"/></f></timeout>
		<completed line="153"><f a=""><e path="Void"/></f></completed>
		<new public="1" line="15"><f a="fixture">
	<c path="utest.TestFixture"><c path="utest.TestHandler.T"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="C:\Programmi\Motion-Twin\haxe\haxe/std/haxe/io/BytesData.hx"><c path="neko.NativeString"/></typedef>
	<class path="utest.TestFixture" params="T" file="src/utest/TestFixture.hx">
		<target public="1" set="null"><c path="utest.TestFixture.T"/></target>
		<method public="1" set="null"><c path="String"/></method>
		<setup public="1" set="null"><c path="String"/></setup>
		<teardown public="1" set="null"><c path="String"/></teardown>
		<checkMethod line="15"><f a="name:arg">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></checkMethod>
		<new public="1" line="8"><f a="target:method:?setup:?teardown">
	<c path="utest.TestFixture.T"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Hash" params="T" file="C:\Programmi\Motion-Twin\haxe\haxe/std/Hash.hx">
		<h><d/></h>
		<set public="1" line="61">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" line="76">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" line="96">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" line="125">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" line="155">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" line="181">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" line="218">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" line="38">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty hashtable.
	</haxe_doc>
		</new>
		<haxe_doc>
	Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.
</haxe_doc>
	</class>
	<class path="@Main" params="" file=""><init line="1" static="1"><e path="Void"/></init></class>
</haxe>